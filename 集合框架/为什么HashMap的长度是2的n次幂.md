[返回目录](../README.md)

### 为什么 HashMap 的长度是 2 的 n 次幂？

- **高效计算索引**。根据 hashcode 计算下标的公式，在 `length` 是 2 的 n 次幂时，这两个公式等效，但明显与操作的效率高于取余。
```java
    int index = h & (length - 1);
    //int index = h % length;
```


- **减小扩容的计算量**
在 JDK1.8 里面，扩容的时候不再像 1.7 那样把所有元素遍历并重新计算索引（扩容前后处在同一个节点下的元素会逆序），而是利用扩容长度大了一倍，和 hashcode 与之后结果会**多保留一位**，那这一位要么是 1 要么是 0，**所以元素的新索引要么不变，要么等于原索引 + 原始长度**。并且扩容前后同一个节点下的元素顺序保持不变（没有变成红黑树前）。

- **其他好处**
1.8 中，`ConcurrentHashMap` 默认值初始化后，`sizeCtl` 里保存的是下次扩容的门限值（默认 `16 * 0.75`），`sizeCtl` 负数表示正在初始化或者扩容，正数时的大小为 `n - (n >>> 2)`，这个和 `n * 0.75` 等效，减少了一丢丢计算量。