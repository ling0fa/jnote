[返回目录](../README.md)

### 对象的回收

- 程序计数器、虚拟机栈、本地方法栈的内存分配和回收，都随线程而生，随线程而灭，垃圾回收针对的目标主要还是**堆内存**。
- 判断对象存活，引用计数法，是一种简单高效的方法，但无法解决对象间的**循环引用**问题，JVM 没有采用这种方法。
- JVM 使用**可达性分析**（Reachability Analysis）来判断对象的死活，原理就是从 GC Roots 出发，能被引用的就是活的对象，否则是可以清除的对象。GC Roots 包括下面四种，可以看出，GC Roots 具有全局、静态、上下文特性。
    - 栈（本地变量表）中引用的对象。
    - 方法区中静态属性引用的对象。
    - 方法区中常量引用的对象。
    - native 方法引用的对象。

- 从引用延伸出来四种引用类型，常见的强引用，会被 GC 回收的软引用、弱引用，用于垃圾回收分析的虚引用，设置对象为虚引用的唯一目的，用于对象被回收前放入引用队列，在真正被回收前做一些事。

---

- 对象被回收，系统会调用对象的 finalize 方法前，对象会先被放入一个叫 F-Queue 的队列，稍后由系统线程 Finalizer 线程（deamon 线程）来执行。
- 如果在 finalize 方法里对象又变得可用，就会逃脱本次制裁，但对象的 finalize 方法**只会被调用一次**，所以最终还是逃脱不了垃圾回收器的制裁。
- finalize 方法应尽量避免使用，这个只是在 Java 诞生之初让 C++ 程序员更容易接受 Java 而做的妥协。

---

- 回收方法区，常量池中的常量没有被引用就可以被回收，但类的回收条件就**苛刻**的多，但在大量使用反射、动态代理、CGLib、JSP、OSGi 和频繁自定义 ClassLoader 的场景都需要对方法区回收，保证方法区不溢出。
- 同时满足下面三个条件，类才会被回收：
    - 类的所有实例被回收。
    - Class 对象没有被引用，没有反射访问该类的方法。
    - 加载类的 ClassLoader 被回收。