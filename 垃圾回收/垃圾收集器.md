### 垃圾收集器

![](./collectors.jpg)

##### Serial 收集器

- 单线程收集，工作时暂停所有工作线程。
- 单 CPU 时相对效率较高，适用于占用内存小的简单应用程序，如命令行工具。

#### ParNew 收集器

- Serial 的多线程版本。Server 模式下新生代首选的收集器。只有它可以和 CMS 协同工作。
- 默认收集线程数和 CPU 数量相同，CPU 非常多时，使用 `-XX:ParallelGCThreads` 来指定回收线程数。
- ParNew 的 Par 是 Parallel 并行的意思，和 Concurrent 并发是有区别的。

#### Parallel Scavenge 收集器

- 和 ParNew 类似，着重点在于达到可控的吞吐量，常被称为“吞吐量优先”收集器。
    ```
        吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
    ```
    高吞吐量意味着高效利用 CPU 时间，尽快完成计算任务，适用于后台运算，不需要太多交互的地方。
- 提供两个参数精确控制吞吐量：
    - `-XX:MaxGCPauseMills`：设置一个毫秒数，收集器将尽可能保证内存回收时间不超过这个值。这么做是通过减小新生代大小和吞吐量换取得，把新生代调小一点，收集肯定会快一些，但收集也更频繁一些， 所以吞吐量也会下降。
    - `-XX:GCTimeRatio`：设置一个 0 到 100 整数，垃圾收集时间占总时间的占比，即 `1-吞吐率`，例如设置 99，那么最大允许的垃圾收集时间是 1/(1+99)。

- 收集器另外一个特点是**自适应**，使用开关参数 `-XX:+UseAdaptiveSizePolicy`，打开后，就不用规划新生代、新生代和 Survivor 的比例等参数，JVM 会根据当前运行情况，动态调整以提供最合适的停顿时间或最大的吞吐量。只需要给虚拟机一个目标，是更关心停顿时间（MaxGCPauseMills）还是吞吐量（GCTimeRatio），其他交给虚拟机自动调节。

#### Serial Old 收集器

- Serial 的老年代版本，使用单线程，标记整理算法。
- 主要用于单线程应用程序的老年代，或者是 CMS 的后备方案，在 CMS 发生 Concurrent Mode Failure 时使用。

#### Parallel Old 收集器

- Parallel Scavenge 的老年代版本，使用多线程，标记整理算法。
- 注重吞吐量以及 CPU 资源敏感的场景，和 Parallel Scavenge 配合使用，是“吞吐量优先”收集器名副其实的组合。