[返回目录](../README.md)

### 垃圾收集器

![](./collectors.jpg)

#### Serial 收集器

- 单线程收集，工作时暂停所有工作线程。
- 单 CPU 时相对效率较高，适用于占用内存小的简单应用程序，如命令行工具。

#### ParNew 收集器

- Serial 的多线程版本。Server 模式下新生代首选的收集器。只有它可以和 CMS 协同工作。
- 默认收集线程数和 CPU 数量相同，CPU 非常多时，使用 `-XX:ParallelGCThreads` 来指定回收线程数。
- ParNew 的 Par 是 Parallel 并行的意思，和 Concurrent 并发是有区别的。

#### Parallel Scavenge 收集器

- 和 ParNew 类似，着重点在于达到可控的吞吐量，常被称为“吞吐量优先”收集器。
    ```
        吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
    ```
    高吞吐量意味着高效利用 CPU 时间，尽快完成计算任务，适用于后台运算，不需要太多交互的地方。
- 提供两个参数精确控制吞吐量：
    - `-XX:MaxGCPauseMills`：设置一个毫秒数，收集器将尽可能保证内存回收时间不超过这个值。这么做是通过减小新生代大小和吞吐量换取得，把新生代调小一点，收集肯定会快一些，但收集也更频繁一些， 所以吞吐量也会下降。
    - `-XX:GCTimeRatio`：设置一个 0 到 100 整数，垃圾收集时间占总时间的占比，即 `1-吞吐率`，例如设置 99，那么最大允许的垃圾收集时间是 1/(1+99)。

- 收集器另外一个特点是**自适应**，使用开关参数 `-XX:+UseAdaptiveSizePolicy`，打开后，就不用规划新生代、`SurvivorRatio` 参数，JVM 会根据当前运行情况，动态调整以提供最合适的停顿时间或最大的吞吐量。只需要给虚拟机一个目标，是更关心停顿时间（MaxGCPauseMills）还是吞吐量（GCTimeRatio），其他交给虚拟机自动调节。

#### Serial Old 收集器

- Serial 的老年代版本，使用单线程，标记整理算法。
- 主要用于单线程应用程序的老年代，或者是 CMS 的后备方案，在 CMS 发生 Concurrent Mode Failure 时使用。

#### Parallel Old 收集器

- Parallel Scavenge 的老年代版本，使用多线程，标记整理算法。
- 注重吞吐量以及 CPU 资源敏感的场景，和 Parallel Scavenge 配合使用，是“吞吐量优先”收集器**名副其实**的组合。

#### CMS 收集器

- Concurrent Mark Sweep 收集器，是一种获取最短回收停顿时间的收集器，符合停顿时间短的需求，例如互联网网站，B/S 服务端。
- 基于**标记清除**，分为四个步骤：
    - 初始标记（CMS initial mark)
    - 并发标记（CMS concurrent mark）
    - 重新标记（CMS remark）
    - 并发清除（CMS concurrent sweep）
- `初始标记`和`重新标记`都会暂停所有工作线程。`并发标记`和`并发清除`都是和用户线程一起工作。
- 初始标记仅仅是标记 GC Roots 能关联的对象，速度很快。
- 并发标记是进行 GC Roots 追踪的阶段。
- 重新标记是修正在并发标记期间，标记发生变化的对象，时间远比并发标记短。
- 并发清除，清除无用的对象。
<br>
- 由于耗时最长的并发标记和并发清除，都是可以和用户线程一起工作，所以 CMS 整体上停顿时间很短。
- 但也有三个明显缺点：
    1. **对 CPU 资源非常敏感**。在两个并发阶段，虽然是和用户线程一起工作，但会因为占用了线程而使程序变慢，吞吐量下降。所以 CPU 核数较小时，不建议使用。
    2. **无法处理浮动垃圾**。浮动垃圾是由于在并发清理阶段，新的垃圾会产生，这些新的垃圾称为浮动垃圾，只能留到下一次清理。也就是说要预留一部分空间给用户线程使用，如果不足就出现 Concurrent Mode Failure，进而导致另一次 Full GC 的产生（Serial Old）。`-XX:CMSInitiatingOccupancyFraction` 来设置触发的百分比，如果老年代空间增长较慢，可以适当提高该阈值。
    3. **产生内存碎片**。标记清除算法都会产生碎片。可以打开 `-XX:UseCMSCompactAtFullCollection` 参数，在 FullGC 时开启内存碎片整理。

#### G1 收集器

- Garbage First 收集器是当前最前沿的垃圾收集器，面向服务端，HotSpot 团队给予它的使命是在未来替换 CMS 收集器。
- G1 的优点：
    - 利用多核 CPU 的优势，尽量缩短 STW 的时间。
    - 分代收集。
    - 空间整合。整体来看是标记整理，局部（两个 Region 之间）来看，基于复制算法，但收集完后会整理碎片，提供规整的可用内存。
    - 可预测的停顿。收集器将内存划分多个 Region，并跟踪区域内垃圾回收的价值，维护一个优先列表，根据允许的收集时间，优先收集价值最大的区域（Garbage First 名称的由来）。
- 类似 OopMap，每个 Region 有一个 Remembered Set，使用 RS 可以避免全堆扫描。
- 四个步骤：
    - 初始标记（Initial Marking）
    - 并发标记（Concurrent Marking）
    - 最终标记（Final Marking）
    - 筛选回收（Live Data Counting and Evacuation）
- `初始阶段`、`最终标记`、`筛选回收`都会暂停工作线程。
- 初始标记仅仅是标记 GC Roots 能直接关联的对象，耗时很短。
- 并发标记耗时较长，但可以和用户线程一起工作。
- 最终标记和筛选回收也是修正引用变化的对象，根据价值度优先回收一部分 Region。