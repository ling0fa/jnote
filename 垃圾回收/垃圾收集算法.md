### 垃圾收集算法

1. 标记-清除（Mark-Sweep）算法。缺点是标记和清除两个过程效率都比较低，且容易产生碎片。

2. 复制（Copying）算法。**新生代使用**。复制存活的对象到另一个区域，使用过的区域一次性清理掉。缺点是内存利用率低。Eden:S0:S1 默认是 8:1:1，是因为绝大多数对象都是朝生夕死，所以用较小的空间来存放活的对象就可以了。

3. 标记-整理（Mark-Compact）算法。**老年代使用**。标记清除后，再将活着的对象移动到一端，其他地方的就干掉。

4. 分代收集（Generation Collection）算法。根据对象生命周期，将内存划分为多块，使用不同的收集算法。


##### HotSpot 的算法实现

**枚举根节点**

- 可达性分析时，内存区域有上百兆都是很正常的情况，挨个检查会消耗很多时间。同时，GC 工作时暂停所有线程，是因为不允许 GC 过程中，引用关系还在不停的变化。
- 为了减小这两个步骤的时间，HotSpot 使用 OopMap 的数据结构，在类加载完后，对象的位置和类型会被记录下来，JIT 编译时，也会记录引用的位置，这样 GC 的时候，只扫描这些区域就可以了。

**安全点**

- 先说说保守式 GC 和准确式 GC。
- **保守式 GC** 如果 JVM 选择不记录任何类型的数据，就无法知道内存某个位置的数据类型，GC 的时候就要扫描整个内存区域，以确定它是不是指向了一个堆里的对象。
- **半保守式 GC** 在对象上记录类型信息，扫描过程和保守式 GC 一样。
- 上面这两种 GC，对有些对象已经死了，但疑似有指针指向他们，就无法被回收。
- **准确式 GC** JVM 能判断栈、寄存器等位置的数据是不是指向堆的引用，HotSpot 使用了一种 OopMap 的数据结构，记录了**该类型的对象内，什么样的偏移量，是什么类型的数据**，这些数据在类的加载过程（准备阶段）中就已经可以知道。
- 所以如果每条指令操作数据后都更新到 OopMap，OopMap 就会很大，所以就选取了一些关键点来记录 OopMap，这些关键点就是**安全点**（Safe Point），只有在安全点上，引用的类型和位置才是确定，也就是 GC 不能随时进行的原因。
- 安全点包括：
    - 循环的末尾（防止大循环老是不结束）
    - 方法临返回前，调用方法的 call 指令后
    - 可能抛出异常的位置
- 平时 OopMap 是压缩存在内存里，使用的时候才解压。
- JNI 方法并不是由 JVM 执行，缺少 OopMap 信息，在调用时，JNI 和 Java 方法的边界使用句柄包装起来，通过句柄间接访问堆对象，GC 时候不扫描栈，而是扫描句柄。由于是二次引用，且存在句柄的开销，这是访问 JNI 方法较慢的原因之一。

**安全区域**

- 如果线程没有分配 CPU 时间，例如处于 Sleep 状态，就无法响应 GC 的信号，执行到安全点再挂起。
- 安全区域是指，在一段代码中，引用关系不发生变化，在这个区域的任意地方 GC 都是安全的。相当于是扩展的安全点。
- 当线程进入安全区域时，会标记自己进入安全区域，这时候发生 GC，JVM 可以不用管这个线程，线程离开安全区域时，要等待 GC 执行完成才能离开。