[返回目录](../README.md)

### 运行时数据区域

根据《Java 虚拟机规范 SE7 版》规定，JVM 运行时管理的内存区域包含**方法区、虚拟机栈、本地方法栈、堆区、程序计数器**。

- **程序计数器**

    - 空间较小。可以看作是当前线程执行字节码的行号指示器。每个线程独立拥有一个空间，记录执行位置，保证线程切换回来后可以在上一次结束的位置继续执行，但是如果执行的是 native 方法，这个计数器的值为空（Undefined）。此区域是 JVM 规范中**唯一一个**没有规定任何 `OutOfMemoryError` 情况的区域。

- **虚拟机栈**

    - 线程各自的**私有**空间，与线程生命周期相同，描述的是 Java 方法执行的内存模型，即方法栈，存储了局部变量表、操作数栈、动态链接、方法出口等信息。

    - 程序🐒最关心的是**局部变量表**，包含`基本数据类型`、`对象引用`和 `returnAddress`（指向一条字节码指令地址）。long 和 double 基本类型会占用 2 个局部变量空间（Slot），其余都占用一个。局部变量表在编译期**大小就完全确定**，所以进入一个方法，需要在栈中分配多大的空间也完全确定，在运行期间局部变量表的大小不变。

    - JVM 规定，栈太深会抛出 `StackOverflowError`。运行时栈大小是可以扩展的，如果扩展失败，抛出 `OutOfMemoryError`。

- **本地方法栈**

    - 和虚拟机栈非常类似，区别在于是为 native 方法提供的。 HotSpot 虚拟机把虚拟机栈和本地方法栈合二为一管理，也可能抛出上面两种异常。

- **堆**

    - 此区域的唯一目的就是存放对象，**几乎**所有的对象都在这里分配内存。随着 JIT 技术的发展和逃逸分析技术的成熟，栈上分配、标量替换使对象不一定分配在堆上。

    - 堆可以物理不连续，逻辑连续即可，内存分配失败且堆无法再扩展时（-Xmx 和 -Xms 相等时就不用运行时扩展），抛出 `OutOfMemoryError` 异常。

    - 字符串常量池在 1.7 之后从永久代移到了堆区，`String` 的 `intern` 方法可以往字符串常量池添加内容，对于字符串有大量重复的情况，常量池能提升效率，否则性能可能会有损耗（字符串存在一个 `HashTable` 里），常量池无法再扩展也会抛出 `OutOfMemoryError` 异常。另外，YGC 会扫描 `HashTable` 里的字符串，`HashTable` 太大，会导致 YGC 变慢。

- **方法区**
    - 存储类信息、常量、静态变量、即时编译后的代码数据等。

    - 这个区域很少存在垃圾回收，主要针对常量池的回收和类型卸载，由于回收条件苛刻，回收效果非常一般，但也是必须的。

    - 运行时常量池，是方法区的一部分，存放编译期生成的各种字面量和符号引用，在类加载后存放在常量池里。

- **堆外内存**
    - 1.4 引入了 NIO，基于 `Channel` 与 `Buffer` 的 IO 方式，使用 `Unsafe` 的 `native` 函数直接在堆外分配内存，对这块内存的操作和回收也是 `Unsafe` 的 `native` 函数完成的，相当于 `DirectByteBuffer` 是一个壳，GC 时将不可达的 `DirectByteBuffer` 对象和关联的堆外内存一起回收。
    
    - 堆外内存在 IO 和网络通信的场景下避免了在 native 堆和 Java 堆中来回复制数据，能明显提高性能。

    - 但在堆外，在 `-Xmx` 参数中体现不出来，使得总使用内存偏大，处理不好会导致 `OutOfMemoryError` 异常。
   
    - 如果 `DirectByteBuffer` 被分配在新生代，由于新生代 GC 评率高，所以不可达的 `DirectByteBuffer` 对象和关联的堆外内存可以很快被回收。但如果晋升或分配到老年代，堆外内存的回收将变得缓慢，极端情况会导致堆外内存溢出，所以使用了 NIO 的代码和框架，需要显示调用 `System.gc()` 来触发 YGC 和 FGC，并且需要在启动参数里去掉 `-XX:+DisableExplicitGC` 参数。
