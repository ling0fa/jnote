[返回目录](../README.md)

### 运行时数据区域

根据《Java 虚拟机规范 SE7 版》规定，JVM 运行时管理的内存区域包含**方法区、虚拟机栈、本地方法栈、堆去、程序计数器**。

- **程序计数器**

    - 空间较小。可以看作是当前线程执行字节码的行号指示器。每个线程独立拥有一个空间，记录执行位置，保证线程切换回来后可以在上一次结束的位置继续执行，但是如果执行的是 native 方法，这个计数器的值为空（Undefined）。此区域是 JVM 规范中**唯一一个**没有规定任何 `OutOfMemoryError` 情况的区域。

- **虚拟机栈**

    - 线程各自的**私有**空间，与线程生命周期相同，描述的是 Java 方法执行的内存模型，即方法栈，存储了局部变量表、操作数栈、动态链接、方法出口等信息。

    - 程序🐒最关心的是**局部变量表**，包含`基本数据类型`、`对象引用`和 `returnAddress`（指向一条字节码指令地址）。long 和 double 基本类型会占用 2 个局部变量空间（Slot），其余都占用一个。局部变量表在编译期**大小就完全确定**，所以进入一个方法，需要在栈中分配多大的空间也完全确定，在运行期间局部变量表的大小不变。

    - JVM 规定，栈太深会抛出 `StackOverflowError`。运行时栈大小是可以扩展的，如果扩展失败，抛出 `OutOfMemoryError`。

- **本地方法栈**

    - 和虚拟机栈非常类似，区别在于是为 native 方法提供的。 HotSpot 虚拟机把虚拟机栈和本地方法栈合二为一管理，也可能抛出上面两种异常。

- **堆**

    - 此区域的唯一目的就是存放对象，**几乎**所有的对象都在这里分配内存。随着 JIT 技术的发展和逃逸分析技术的成熟，栈上分配、标量替换使对象不一定分配在堆上。

    - 堆可以物理不连续，逻辑连续即可，内存分配失败且堆无法再扩展时（-Xmx 和 -Xms 相等时就不用运行时扩展），抛出 `OutOfMemoryError` 异常。

- **方法区**
    - 存储类信息、常量、静态变量、即时编译后的代码数据等。

    - 这个区域很少存在垃圾回收，主要针对常量池的回收和类型卸载，由于回收条件苛刻，回收效果非常一般，但也是必须的。

    - 运行时常量池，是方法区的一部分，存放编译期生成的各种字面量和符号引用，在类加载后存放在常量池里。运行时也可以在常量池添加内容，例如 `String` 的 `intern` 方法。常量池无法再扩展也会抛出 `OutOfMemoryError` 异常。

- **直接内存**
    - 1.4 引入了 NIO，基于 `Channel` 与 `Buffer` 的 IO 方式，使用 native 函数直接在堆外分配内存，然后通过堆中的 `DirectByteBuffer` 对象来进行操作。在某些场景下避免了在 native 堆和 Java 堆中来回复制数据，能明显提高性能。

    - 但在堆外，在 `-Xmx` 参数中体现不出来，使得总使用内存偏大，处理不好会导致 `OutOfMemoryError` 异常。
